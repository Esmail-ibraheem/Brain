/* autogenerated by Processing revision 1293 on 2023-12-10 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Brain_Simulator extends PApplet {

private static final int SIZE = 20;
private static final int hiddenNodes = 18; 
private static final int hiddenLayers = 2; 
private static final int fps = 100;

int highscore = 0;

float mutationRate = 0.05f;
float defaultmutation = mutationRate;

boolean humanPlaying = false; 
boolean replayBest = true;  
boolean seeVision = false;  
boolean modelLoaded = false;

PFont font;

ArrayList<Integer> evolution;

Snake snake;
Snake model;

Candidates candidate ; 

public void settings() {
    size(1200,800);
}

public void setup() {
    font = createFont("IBMPlexSans-BoldItalic.ttf",32);
    evolution = new ArrayList<Integer>();
    frameRate(fps);
    if(humanPlaying) {
        snake = new Snake();
    } else {
        candidate = new Candidates(2000); 
    }
}

public void draw() {
    background(0);
    noFill();
    stroke(250);
    line(400,0,400,height);
    rectMode(CORNER);
    rect(400 + SIZE,SIZE,width-400-40,height-40);
    textFont(font);

    if(humanPlaying) {
        snake.move();
        snake.snake_Visualizer();
        fill(150);
        textSize(20);
        text("SCORE : "+snake.score,500,50);
        if(snake.dead) {
            snake = new Snake(); 
        }
    } else {
        if(!modelLoaded) {
            if(candidate.check_dead()) {
                highscore = candidate.bestSnake.score;
                candidate.calculate_Fitness();
                candidate.natural_Selection();
            } else {
                candidate.update_snakes();
                candidate.visualizer(); 
            }
            fill(220, 220, 220);
            textSize(20);
            textAlign(LEFT);
            text("GEN ALGORITHM: "+candidate.generation,125,60);
            text("BEST FITNESS : "+candidate.bestFitness,125,90);
            text("MOVES LEFT : "+candidate.bestSnake.movesLeft,450,60);
            text("SCORE : "+candidate.bestSnake.score,450,80);
            text("HIGHSCORE : "+highscore,450,100);
      
            text("NN Architecture Type: FeedForword",450,height-90);
            text("NN Architecture: [24, 18, 18, 4]",450,height-60);
            text("Snake Vision: 8 directions",450,height-30);

            text("INPUT LAYER: 24 Nodes",90,height-70);
            text("HIDDEN LAYER: 2/18 Nodes",90,height-40);
            text("OUTPUT LAYER: 4 Nodes",90,height-10);
        } else {
            model.snake_vision();
            model.snake_decision();
            model.move();
            model.snake_Visualizer();
            model.brain.neuralNetwork_Visualizer(0,0,360,790,model.vision, model.decision);
            if(model.dead) {
                Snake newmodel = new Snake();
                newmodel.brain = model.brain.clone();
                model = newmodel;
        
            }
            textSize(25);
            fill(150);
            textAlign(LEFT);
            text("SCORE : "+model.score,120,height-45);
        }
        textAlign(LEFT);
        textSize(18);
        fill(255,0,0);
        text("RED < 0",110,height-90);
        fill(0,255,0);
        text("BLUE > 0",220,height-90);
    }
}

class Candidates{
    Snake[] snakes;
    Snake bestSnake;
   
    int bestSnakeScore = 0;
    int generation = 0;
    int samebest = 0;
   
    float bestFitness = 0;
    float fitnessSum = 0;

    Candidates(int size){
        snakes = new Snake[size] ;
        for(int i=0; i<snakes.length; i++){
            snakes[i] = new Snake() ; 
        }
        bestSnake = snakes[0].clone();
        bestSnake.replay = true;
    }
    public void visualizer() {  
      if(replayBest) {
        bestSnake.snake_Visualizer();
        bestSnake.brain.neuralNetwork_Visualizer(0,0,360,790,bestSnake.vision, bestSnake.decision);  
      } else {
         for(int i = 0; i < snakes.length; i++) {
            snakes[i].snake_Visualizer(); 
         }
      }
   }
    public boolean check_dead(){
        for(int i=0; i<snakes.length; i++){
            if(!snakes[i].dead){
                return false;
            }
        }
        if(!bestSnake.dead){
            return false;
        }
        return true;
    }
    public void update_snakes(){
        if(!bestSnake.dead){
            bestSnake.snake_vision() ;
            bestSnake.snake_decision() ;
            bestSnake.move() ; 
        }
        for(int i=0; i<snakes.length; i++){
            if(!snakes[i].dead){
                snakes[i].snake_vision() ;
                snakes[i].snake_decision() ;
                snakes[i].move() ; 
            }
        }
    }
    public void set_Best_Snake(){
        float maximum = 0;
        int maximumIndex = 0;

        for(int i=0; i<snakes.length; i++){
            if(snakes[i].fitness>maximum){
                maximum = snakes[i].fitness ; 
                maximumIndex = i ; 
            }
        }
        if(maximum>bestFitness){
            bestFitness = maximum ;
            bestSnake = snakes[maximumIndex].clone_for_replay() ; 
            bestSnakeScore = snakes[maximumIndex].score ;  
        }else{
            bestSnake = bestSnake.clone_for_replay() ;
        }
    }
    public Snake parent_Selection(){
        float rand = random(fitnessSum) ;
        float summation = 0;
        for(int i=0; i<snakes.length; i++){
            summation+=snakes[i].fitness ;

            if(summation>rand){
                return snakes[i] ; 
            } 
        }
        return snakes[0] ; 
    }
    public void natural_Selection() {

        Snake[] newSnakes = new Snake[snakes.length];
      
        set_Best_Snake();
        calculate_Finess_summation();
      
        newSnakes[0] = bestSnake.clone();  
        for(int i = 1; i < snakes.length; i++) {
            Snake child = parent_Selection().corssOver_Operator(parent_Selection());
            child.mutate();
            newSnakes[i] = child;
        }
        snakes = newSnakes.clone();
        evolution.add(bestSnakeScore);
        generation+=1;
    }
    public void mutate(){
        for(int i=0; i<snakes.length; i++){
            snakes[i].mutate() ; 
        }
    }
    public void calculate_Fitness(){
        for(int i=0; i<snakes.length; i++){
            snakes[i].calculate_Fitness() ; 
        }
    }
    public void calculate_Finess_summation(){
        fitnessSum = 0;
        for(int i=0; i<snakes.length; i++){
            fitnessSum = snakes[i].fitness ; 
        }
    }
}
class Food {
    PVector pos;
    
    Food() {
      int x = 400 + SIZE + floor(random(38))*SIZE;
      int y = SIZE + floor(random(38))*SIZE;
      pos = new PVector(x,y);
    }
    
    public void food_Visualizer() {
       stroke(0);
       fill(255,0,0);
       ellipse(pos.x,pos.y,SIZE,SIZE);
    }
    
    public Food clone() {
       Food clone = new Food();
       clone.pos.x = pos.x;
       clone.pos.y = pos.y;
       
       return clone;
    }
}
class Matrix{
    int rows, colunms ;
    float[][] matrix ;

    Matrix(int r, int c){
        rows = r ;
        colunms = c;
        matrix = new float[rows][colunms] ;
    }
    Matrix(float[][] m){
        matrix = m ;
        rows = matrix.length;
        colunms = matrix[0].length;
    }
    public void matrix_Output(){
        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                print(matrix[i][j] + " ") ; 
            }println() ;
        }println() ;
    }
    public void weights_Randomize(){
        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                matrix[i][j] = random(-1, 1);
            }
        }
    }
    public void mutation(float mutationRate){
        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                float rand = random(1) ; 
                if(rand<mutationRate){
                    matrix[i][j]+=randomGaussian()/5;

                    if(matrix[i][j]>1){
                        matrix[i][j]=1 ;
                    }
                    if(matrix[i][j]<-1){
                        matrix[i][j]=-1 ;
                    }
                }
            }
        }
    }
    public float reLU_Function(float y){
        return max(0,y) ;
    }
    public Matrix add_Bias(){
        Matrix biasMatrix = new Matrix(rows+1, 1) ; 
        for(int i=0; i<rows; i++){
            biasMatrix.matrix[i][0] = matrix[i][0] ; 
        }
        biasMatrix.matrix[rows][0] = 1;
        return biasMatrix ;
    }
    public Matrix activation_Function(){
        Matrix activationMatrix = new Matrix(rows, colunms) ;
        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                activationMatrix.matrix[i][j] = reLU_Function(matrix[i][j]) ; 
            }
        }
        return activationMatrix ;
    }
    public Matrix corssOver_Operator(Matrix partnerMatrix){
        Matrix childMatrix = new Matrix(rows, colunms) ;

        int randomRows = floor(random(rows)) ;
        int randomColunms = floor(random(colunms)) ;

        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                if((i<randomRows) || (i==randomRows && j<=randomColunms)){
                    childMatrix.matrix[i][j] = matrix[i][j] ;
                }else{
                    childMatrix.matrix[i][j] = partnerMatrix.matrix[i][j] ; 
                }
            }
        }
        return childMatrix ; 
    }
    public Matrix dot_Product(Matrix secondMatrix){
        Matrix resaultMatrix = new Matrix(rows, secondMatrix.colunms);

        if(colunms==secondMatrix.rows){
            for(int i=0; i<rows; i++){
                for(int j=0; j<secondMatrix.colunms; j++){
                    float summation = 0;
                    for(int k=0; k<colunms; k++){
                        summation+= matrix[i][k] * secondMatrix.matrix[k][j] ; 
                    }
                    resaultMatrix.matrix[i][j] = summation ; 
                }
            }
        }
        return resaultMatrix;
    }
    public Matrix clone(){
        Matrix cloneMatrix = new Matrix(rows, colunms) ;
        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                cloneMatrix.matrix[i][j] = matrix[i][j] ; 
            }
        }
        return cloneMatrix ; 
    }
    public Matrix convert_singl_colunm_to_Array(float[] arr){
        Matrix colunmMatrix = new Matrix(arr.length, 1);
        for(int i=0; i<arr.length; i++){
            colunmMatrix.matrix[i][0] = arr[i] ; 
        }
        return colunmMatrix ; 
    }
    public float[] convert_to_Array(){
        float[] arr = new float[rows * colunms] ;
        for(int i=0; i<rows; i++){
            for(int j=0; j<colunms; j++){
                arr[i+j * colunms] = matrix[i][j] ; 
            }
        }
        return arr ; 
    }
}
class NeuralNetwork{
    int inputNodes, hiddenNodes, outputNodes, hiddenLayers ;
    Matrix[] weights ;

    NeuralNetwork(int iNodes, int hNodes, int oNodes, int hLayers){
        inputNodes = iNodes ;
        hiddenNodes = hNodes;
        outputNodes = oNodes;
        hiddenLayers = hLayers ;

        weights = new Matrix[hiddenLayers+1] ;
        weights[0] = new Matrix(hiddenNodes, inputNodes+1) ;
        for(int i=1; i<hiddenLayers; i++){
            weights[i] = new Matrix(hiddenNodes, hiddenNodes+1) ; 
        }
        weights[weights.length-1] = new Matrix(outputNodes, hiddenNodes+1) ;

        for(Matrix weight:weights){
            weight.weights_Randomize() ; 
        }
    }
    public void mutate(float mutationRate){
        for(Matrix weight:weights){
            weight.mutation(mutationRate) ; 
        }
    }
    public float[] activation_Function_Output(float[] inputArray){
        Matrix input = weights[0].convert_singl_colunm_to_Array(inputArray) ;
        Matrix currentBias = input.add_Bias() ;

        for(int i=0; i<hiddenLayers; i++){
            Matrix hiddenLayerInput = weights[i].dot_Product(currentBias) ; 
            Matrix hiddenLayerOutput = hiddenLayerInput.activation_Function() ; 
            currentBias = hiddenLayerOutput.add_Bias() ; 
        }

        Matrix outputLayerInput = weights[weights.length-1].dot_Product(currentBias) ;
        Matrix output = outputLayerInput.activation_Function() ; 

        return output.convert_to_Array() ;  
    }
    public NeuralNetwork corssOver_Operator(NeuralNetwork partnerNeuralNetwork){
        NeuralNetwork childNeuralNetwork = new NeuralNetwork(inputNodes, hiddenNodes, outputNodes, hiddenLayers) ;
        for(int i=0; i<weights.length; i++){
            childNeuralNetwork.weights[i] = weights[i].corssOver_Operator(partnerNeuralNetwork.weights[i]) ; 
        }
        return childNeuralNetwork;
    }
    public NeuralNetwork clone(){
        NeuralNetwork cloneNeuralNetwork = new NeuralNetwork(inputNodes, hiddenNodes, outputNodes, hiddenLayers) ;
        for(int i=0; i<weights.length; i++){
            cloneNeuralNetwork.weights[i] = weights[i].clone() ; 
        }
        return cloneNeuralNetwork;
    }
    public Matrix[] pull(){
        Matrix[] model = weights.clone(); 
        return model ; 
    }

    public void neuralNetwork_Visualizer(float xPosition, float yPosition, float w, float h, float[]vision, float[]decision){
        float space = 5;
        float neuronSize = (h - (space*(inputNodes-2))) / inputNodes;
        float neuronSpace = (w - (weights.length*neuronSize)) / weights.length;
        float hiddenBuffer = (h - (space*(hiddenNodes-1)) - (neuronSize*hiddenNodes))/2;
        float outputBuffer = (h - (space*(outputNodes-1)) - (neuronSize*outputNodes))/2;

        int maximumIndex = 0;
        for(int i=0; i<decision.length; i++){
            if(decision[i]>decision[maximumIndex]){
                maximumIndex = i ;
            }
        }

        int layer_Count = 0;

        for(int i=0; i<inputNodes; i++){
            if(vision[i]!=0){
                fill(0,255,0) ; 
            }else{
                noFill();
            }
            stroke(255);
            ellipseMode(CORNER);
            ellipse(xPosition,yPosition+(i*(neuronSize+space)),neuronSize,neuronSize);
            textSize(neuronSize/2);
            textAlign(CENTER,CENTER);
            fill(0);
            text(i,xPosition+(neuronSize/2),yPosition+(neuronSize/2)+(i*(neuronSize+space)));
        }
        layer_Count++ ; 

        for(int l=0; l<hiddenLayers; l++){
            for(int i=0; i<hiddenNodes; i++){
                if(vision[i]!=0){
                    fill(0,255,0) ; 
                }else{
                    noFill();
                }
                ellipseMode(CORNER);
                ellipse(xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace),yPosition+hiddenBuffer+(i*(neuronSize+space)),neuronSize,neuronSize);
            }
            layer_Count++ ; 
        }

        for(int i=0; i<outputNodes; i++){
            if(i==maximumIndex){
                fill(0,255,0) ; 
            }else{
                noFill();
            }
            stroke(255);
            ellipseMode(CORNER);
            ellipse(xPosition+(layer_Count*neuronSpace)+(layer_Count*neuronSize),yPosition+outputBuffer+(i*(neuronSize+space)),neuronSize,neuronSize);
        }

        layer_Count = 1;

        for(int i=0; i<weights[0].rows; i++){
            for(int j=0; j<weights[0].colunms-1; j++){
                if(weights[0].matrix[i][j]<0){
                    if(vision[j]!=0){
                        stroke(255,0,0) ; 
                    }
                }else{
                    if(vision[j]!=0){
                        stroke(0,0,255) ; 
                    }
                }
                line(xPosition+neuronSize,yPosition+(neuronSize/2)+(j*(space+neuronSize)),xPosition+neuronSize+neuronSpace,yPosition+hiddenBuffer+(neuronSize/2)+(i*(space+neuronSize)));
            }
        }

        layer_Count++ ;

        for(int l=1; l<hiddenLayers; l++){
            for(int i=0; i<weights[l].rows; i++){
                for(int j=0; j<weights[l].colunms-1; j++){
                    if(weights[l].matrix[i][j]<0){
                        if(vision[j]!=0){
                            stroke(255,0,0) ;
                        }
                    }else{
                        if(vision[j]!=0){
                            stroke(0,0,255) ; 
                        }
                    }
                    line(xPosition+(layer_Count*neuronSize)+((layer_Count-1)*neuronSpace),yPosition+hiddenBuffer+(neuronSize/2)+(j*(space+neuronSize)),xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace),yPosition+hiddenBuffer+(neuronSize/2)+(i*(space+neuronSize)));
                }
            }
            layer_Count++ ; 
        }

        for(int i=0; i<weights[weights.length-1].rows; i++){
            for(int j=0; j<weights[weights.length-1].colunms-1; j++){
                if(weights[weights.length-1].matrix[i][j]<0){
                    if(vision[j]!=0){
                            stroke(255,0,0) ;
                    }
                }else{
                    if(vision[j]!=0){
                            stroke(0,0,255) ; 
                    }
                }
                line(xPosition+(layer_Count*neuronSize)+((layer_Count-1)*neuronSpace),yPosition+hiddenBuffer+(neuronSize/2)+(j*(space+neuronSize)),xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace),yPosition+outputBuffer+(neuronSize/2)+(i*(space+neuronSize)));
            }
        }

        fill(0);
        textSize(12);
        textAlign(CENTER,CENTER);
        text("Up",xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace)+neuronSize/2,yPosition+outputBuffer+(neuronSize/2));
        text("Down",xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace)+neuronSize/2,yPosition+outputBuffer+space+neuronSize+(neuronSize/2));
        text("Left",xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace)+neuronSize/2,yPosition+outputBuffer+(2*space)+(2*neuronSize)+(neuronSize/2));
        text("Right",xPosition+(layer_Count*neuronSize)+(layer_Count*neuronSpace)+neuronSize/2,yPosition+outputBuffer+(3*space)+(3*neuronSize)+(neuronSize/2));
    }
}
class Snake{
    int score = 1;
    int movesLeft = 200;
    int survivleTime = 0;
    int foodIteration = 0;
    float fitness = 0;
    float xVelocity, yVelocity ;
    boolean dead = false;
    boolean replay = false ;
    float[] vision ;
    float[] decision ;

    PVector head;

    ArrayList<PVector>body ;
    ArrayList<Food> foodList ;

    NeuralNetwork brain;
    Food food ;

    Snake(){
        this(hiddenLayers) ;
    }
    Snake(int layers){
        head = new PVector(800,height/2);
        body = new ArrayList<PVector>() ;
        food = new Food() ;
        if(!humanPlaying){
            vision = new float[24] ;
            decision = new float[4] ; 
            foodList = new ArrayList<Food>() ; 
            foodList.add(food.clone()) ;
            brain = new NeuralNetwork(24, hiddenNodes, 4, layers) ; 
            body.add(new PVector(800,(height/2)+SIZE));  
            body.add(new PVector(800,(height/2)+(2*SIZE)));
            score+=2;
        }
    }
    Snake(ArrayList<Food> foods){
        replay = true ;
        body = new ArrayList<PVector>() ;
        vision = new float[24] ;
        decision = new float[4] ; 
        foodList = new ArrayList<Food>(foods.size()) ;
        for(Food f:foods){
            foodList.add(f.clone()) ; 
        } 
        food = foodList.get(foodIteration) ;
        foodIteration++ ;
        head = new PVector(800,height/2);
        body.add(new PVector(800,(height/2)+SIZE));
        body.add(new PVector(800,(height/2)+(2*SIZE)));
        score+=2;
    }
    public boolean check_body_collide(float x, float y){
        for(int i=0; i<body.size(); i++){
            if(x==body.get(i).x && y==body.get(i).y){
                return true ;
            }
        }
        return false;
    }
    public boolean check_food_collide(float x, float y){
        if(x==food.pos.x && y== food.pos.y){
            return true ;
        }
        return false; 
    }
    public boolean check_wall_collide(float x, float y){
        if(x >= width-(SIZE) || x < 400 + SIZE || y >= height-(SIZE) || y < SIZE){
            return true;
        }
        return false; 
    }
    public Snake corssOver_Operator(Snake partnerSnake){
        Snake childSnake = new Snake(hiddenLayers);
        childSnake.brain = brain.corssOver_Operator(partnerSnake.brain) ; 
        return childSnake ;
    }
    public Snake clone_for_replay(){
        Snake clone = new Snake(foodList) ;
        clone.brain = brain.clone() ; 
        return clone;
    }
    public Snake clone(){
        Snake clone = new Snake() ;
        clone.brain = brain.clone() ; 
        return clone; 
    }
    public void mutate(){
        brain.mutate(mutationRate) ; 
    }
    public void calculate_Fitness(){
        if(score<10){
            fitness = (survivleTime*survivleTime) * pow(2,score) ;
        }else{
            fitness = (survivleTime*survivleTime) ; 
            fitness *= pow(2,10) ;
            fitness *= (score-9) ; 
        }
    }
    public void snake_Visualizer() {  
        food.food_Visualizer() ;
        fill(0,255,0);
        stroke(0);
     
        for(int i = 0; i < body.size(); i++) {
            rect(body.get(i).x,body.get(i).y,SIZE,SIZE); 
        }
        if(dead) {
            fill(255);
        } else {
            fill(0,255,0);
        }
        rect(head.x,head.y,SIZE,SIZE);
    }
    public void move() {  
        if(!dead){
            if(!humanPlaying && !modelLoaded) {
                survivleTime++;
                movesLeft--;
            }
            if(check_food_collide(head.x,head.y)) {
                eat();
            }
            shiftBody();
            if(check_wall_collide(head.x,head.y)) {
                dead = true;
            } else if(check_body_collide(head.x,head.y)) {
                dead = true;
            } else if(movesLeft <= 0 && !humanPlaying) {
                dead = true;
            }
        }
    }
    public void eat() {  
        int len = body.size()-1;
        score++;
        if(!humanPlaying && !modelLoaded) {
            if(movesLeft < 500) {
                if(movesLeft > 400) {
                    movesLeft = 500; 
                } else {
                    movesLeft+=100;
                }
            }
        }
        if(len >= 0) {
            body.add(new PVector(body.get(len).x,body.get(len).y));
        } else {
            body.add(new PVector(head.x,head.y)); 
        }
        if(!replay) {
            food = new Food();
            while(check_body_collide(food.pos.x,food.pos.y)) {
                food = new Food();
            }
            if(!humanPlaying) {
                foodList.add(food);
            }
        } else {  
            food = foodList.get(foodIteration);
            foodIteration++;
        }
    }
    public void shiftBody() {  
        float tempx = head.x;
        float tempy = head.y;
        head.x += xVelocity;
        head.y += yVelocity;
        float temp2x;
        float temp2y;
        for(int i = 0; i < body.size(); i++) {
            temp2x = body.get(i).x;
            temp2y = body.get(i).y;
            body.get(i).x = tempx;
            body.get(i).y = tempy;
            tempx = temp2x;
            tempy = temp2y;
        } 
    }

    public float[] look_In_Directions(PVector direction){
        float[] look = new float[3] ;
        boolean foodFound = false;
        boolean bodyFound = false;
        float distance = 0;
        PVector pos = new PVector(head.x, head.y) ;
        pos.add(direction) ;
        distance++ ; 
        while(!check_wall_collide(pos.x, pos.y)){
            if(!foodFound && check_food_collide(pos.x, pos.y)){
                foodFound = true;
                look[0] = 1;
            }
            if(!bodyFound && check_body_collide(pos.x, pos.y)){
                bodyFound = true;
                look[1] = 1 ;
            }
            if(replay && seeVision) {
                stroke(0,255,0);
                point(pos.x,pos.y);
                if(foodFound) {
                    noStroke();
                    fill(255,255,51);
                    ellipseMode(CENTER);
                    ellipse(pos.x,pos.y,5,5); 
                }
                if(bodyFound) {
                    noStroke();
                    fill(102,0,102);
                    ellipseMode(CENTER);
                    ellipse(pos.x,pos.y,5,5); 
                }
            }
            pos.add(direction);
            distance +=1;
        }
        if(replay && seeVision) {
            noStroke();
            fill(0,255,0);
            ellipseMode(CENTER);
            ellipse(pos.x,pos.y,5,5); 
        }
        look[2] = 1/distance;
        return look;
    }

    public void snake_vision(){
        vision = new float[24] ; 
        float[] temp = look_In_Directions(new PVector(-SIZE,0));
        vision[0] = temp[0];
        vision[1] = temp[1];
        vision[2] = temp[2];
        temp = look_In_Directions(new PVector(-SIZE,-SIZE));
        vision[3] = temp[0];
        vision[4] = temp[1];
        vision[5] = temp[2];
        temp = look_In_Directions(new PVector(0,-SIZE));
        vision[6] = temp[0];
        vision[7] = temp[1];
        vision[8] = temp[2];
        temp = look_In_Directions(new PVector(SIZE,-SIZE));
        vision[9] = temp[0];
        vision[10] = temp[1];
        vision[11] = temp[2];
        temp = look_In_Directions(new PVector(SIZE,0));
        vision[12] = temp[0];
        vision[13] = temp[1];
        vision[14] = temp[2];
        temp = look_In_Directions(new PVector(SIZE,SIZE));
        vision[15] = temp[0];
        vision[16] = temp[1];
        vision[17] = temp[2];
        temp = look_In_Directions(new PVector(0,SIZE));
        vision[18] = temp[0];
        vision[19] = temp[1];
        vision[20] = temp[2];
        temp = look_In_Directions(new PVector(-SIZE,SIZE));
        vision[21] = temp[0];
        vision[22] = temp[1];
        vision[23] = temp[2];
    }
    public void snake_decision(){
        decision = brain.activation_Function_Output(vision) ; 
        float maximum = 0;
        int maximumIndex = 0;
        for(int i=0; i<decision.length; i++){
            if(decision[i]>maximum){
                maximum = decision[i];
                maximumIndex = i ; 
            }
        }
        switch(maximumIndex){
            case 0:
                moveUp() ;
                break ;
            case 1:
                moveDown() ;
                break; 
            case 2:
                moveLeft() ;
                break; 
            case 3:
                moveRight() ; 

        }
    }
    public void moveUp() { 
        if(yVelocity!=SIZE) {
            xVelocity = 0; yVelocity = -SIZE;
        }
    }
    public void moveDown() { 
        if(yVelocity!=-SIZE) {
            xVelocity = 0; yVelocity = SIZE; 
        }
    }
    public void moveLeft() { 
        if(xVelocity!=SIZE) {
            xVelocity = -SIZE; yVelocity = 0; 
        }
    }
    public void moveRight() { 
        if(xVelocity!=-SIZE) {
            xVelocity = SIZE; yVelocity = 0;
        }
    }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Brain_Simulator" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
